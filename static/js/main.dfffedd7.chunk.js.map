{"version":3,"sources":["Node.js","Algorithms/Dijkstra.js","Algorithms/BiDijkstra.js","Algorithms/Astar.js","App.js","index.js"],"names":["Node","this","props","onMouseDown","onMouseEnter","onMouseUp","node","className","isWall","isStart","isFinish","id","row","col","React","Component","Dijkstra","grid","startLocation","solve","Finish","NodesVisitedInOrder","UnvisitedNodes","length","column","previous","visited","distance","Infinity","push","startRow","startCol","sort","compareNodes","currentNode","shift","getNeighbours","forEach","neighbour","altDistance","pathInOrder","unshift","VisitedInOrder","nodes","x","y","BiDijkstra","finishLocation","BeginningNodes","EndNodes","FirstHalf","SecondHalf","previousEnd","endDistance","finishRow","finishCol","compareNodesEnd","neighbours","console","log","Astar","h","Math","abs","DEFAULT_START","DEFAULT_FINISH","ALGORITHMS","App","handleMouseDown","state","solving","setState","movingFinish","movingStart","removingWall","placingWall","toggleWall","handleMouseUp","handleMouseEnter","newGrid","slice","finish","solved","startSolving","start","solveSpeed","solver","clearPath","solveMethod","Visited","document","getElementById","classList","add","animateNodes","setTimeout","div","remove","CreateEmptyBoard","rows","cols","board","activeRow","createNode","resetBoard","speed","nodeClass","headClass","i","htmlFor","disabled","onChange","e","Number","target","value","default","onClick","map","rowIndex","key","nodeIndex","src","alt","ReactDOM","render"],"mappings":"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","file":"static/js/main.dfffedd7.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends React.Component {\r\n  render() {\r\n    const { onMouseDown, onMouseEnter, onMouseUp, node } = this.props;\r\n    let className = node.isWall\r\n      ? \"Wall\"\r\n      : node.isStart\r\n      ? \"Start\"\r\n      : node.isFinish\r\n      ? \"Finish\"\r\n      : \"\";\r\n\r\n    return (\r\n      <th\r\n        id={`node ${node.row} ${node.col}`}\r\n        onMouseEnter={() => {\r\n          onMouseEnter(node.row, node.col);\r\n        }}\r\n        onMouseDown={() => {\r\n          onMouseDown(node.row, node.col);\r\n        }}\r\n        onMouseUp={onMouseUp}\r\n        className={className}></th>\r\n    );\r\n  }\r\n}\r\n","//Implementation of Dijkstras shortest path algorithm.\r\nexport default class Dijkstra {\r\n  constructor(grid, startLocation) {\r\n    this.grid = grid;\r\n    this.startRow = startLocation[0];\r\n    this.startCol = startLocation[1];\r\n  }\r\n\r\n  // method to call when solving. Will return an object containing\r\n  // a list of nodes in the order they were visited as well as a list\r\n  // of nodes in the order of the path if a path exists\r\n  solve = () => {\r\n    let NodesVisitedInOrder = []; // list of nodes in the order they are visited while solving\r\n    let UnvisitedNodes = []; // list of all nodes that have not yet been visited\r\n    let Finish; // end node if found to get path\r\n\r\n    // reset nodes and add them to list of univisited nodes.\r\n    for (let row = 0; row < this.grid.length; row++) {\r\n      for (let column = 0; column < this.grid[0].length; column++) {\r\n        this.grid[row][column].previous = null;\r\n        this.grid[row][column].visited = false;\r\n        this.grid[row][column].distance = Infinity;\r\n        UnvisitedNodes.push(this.grid[row][column]);\r\n      }\r\n    }\r\n\r\n    // set distance of start node to 0 and then sort nodes by distance\r\n    this.grid[this.startRow][this.startCol].distance = 0;\r\n    UnvisitedNodes.sort(compareNodes);\r\n\r\n    while (UnvisitedNodes.length > 0) {\r\n      // continuously remove closest node from the list\r\n      let currentNode = UnvisitedNodes.shift();\r\n\r\n      // if we are at the end, set Finish to the node and stop search\r\n      if (currentNode.isFinish) {\r\n        Finish = currentNode;\r\n        break;\r\n      }\r\n\r\n      // if the closest next node has distance infinity without finding a path, we must\r\n      // be unable to reach it so terminate\r\n      if (currentNode.distance === Infinity) {\r\n        Finish = currentNode;\r\n        break;\r\n      }\r\n\r\n      // for each of the neighbours of a node update the distance if the distance through the current node\r\n      // is shorter. if that's the case set that nodes previous node to be this node.\r\n      let neighbours = this.getNeighbours(currentNode);\r\n      neighbours.forEach(neighbour => {\r\n        if (!neighbour.isWall) {\r\n          let altDistance = currentNode.distance + 1;\r\n          if (altDistance < neighbour.distance) {\r\n            neighbour.distance = altDistance;\r\n            neighbour.previous = currentNode;\r\n          }\r\n        }\r\n      });\r\n\r\n      // set node to visited and add it to list of visited nodes. Then sort the list by distance again.\r\n      currentNode.visited = true;\r\n      NodesVisitedInOrder.push(currentNode);\r\n      UnvisitedNodes.sort(compareNodes);\r\n    }\r\n\r\n    let pathInOrder = [];\r\n\r\n    // add nodes of the path by continously looking at previous node from the finish.\r\n    while (Finish.previous) {\r\n      Finish = Finish.previous;\r\n      pathInOrder.unshift(Finish);\r\n    }\r\n\r\n    // returns object containing list of visited nodes in order and path nodes in order form start to finish\r\n    return {\r\n      VisitedInOrder: NodesVisitedInOrder,\r\n      pathInOrder: pathInOrder\r\n    };\r\n  };\r\n\r\n  // given a node, return all the nodes around it. Checks if location is within grid.\r\n  getNeighbours = node => {\r\n    let nodes = [];\r\n\r\n    // checks node above\r\n    if (node.row > 0) nodes.push(this.grid[node.row - 1][node.col]);\r\n\r\n    //checks node below\r\n    if (node.row < this.grid.length - 1) {\r\n      nodes.push(this.grid[node.row + 1][node.col]);\r\n    }\r\n    //checks node to left\r\n    if (node.col > 0) nodes.push(this.grid[node.row][node.col - 1]);\r\n\r\n    //checks node to right\r\n    if (node.col < this.grid[0].length - 1)\r\n      nodes.push(this.grid[node.row][node.col + 1]);\r\n\r\n    return nodes;\r\n  };\r\n}\r\n\r\n// used for sorting. comparse nodes based on distance\r\nconst compareNodes = (x, y) => {\r\n  if (x.distance < y.distance) {\r\n    return -1;\r\n  }\r\n  if (x.distance > y.distance) {\r\n    return 1;\r\n  }\r\n  return 0;\r\n};\r\n","// Search method which uses Dijkstra from both beginning and endpoints.\r\n// When searches meet each other we find the shortest path\r\nexport default class BiDijkstra {\r\n  constructor(grid, startLocation, finishLocation) {\r\n    this.grid = grid;\r\n    this.startRow = startLocation[0];\r\n    this.startCol = startLocation[1];\r\n    this.finishRow = finishLocation[0];\r\n    this.finishCol = finishLocation[1];\r\n  }\r\n\r\n  // method to call when solving. Will return an object containing\r\n  // a list of nodes in the order they were visited as well as a list\r\n  // of nodes in the order of the path if a path exists\r\n  solve = () => {\r\n    let NodesVisitedInOrder = []; // list of nodes in the order they are visited while solving\r\n    let BeginningNodes = []; // List of all nodes that have not been visited from start\r\n    let EndNodes = []; // list of nodes that have not been visited from end\r\n    let FirstHalf = []; // nodes from start to where it meets search from end\r\n    let SecondHalf = []; //nodes from end to where it meets search from start\r\n\r\n    // initialize all nodes and add them to both start and end list.\r\n    for (let row = 0; row < this.grid.length; row++) {\r\n      for (let column = 0; column < this.grid[0].length; column++) {\r\n        this.grid[row][column].previous = null;\r\n        this.grid[row][column].previousEnd = null;\r\n        this.grid[row][column].visited = false;\r\n        this.grid[row][column].distance = Infinity;\r\n        this.grid[row][column].endDistance = Infinity;\r\n        BeginningNodes.push(this.grid[row][column]);\r\n        EndNodes.push(this.grid[row][column]);\r\n      }\r\n    }\r\n\r\n    // set distances for start and end to 0 and sort based on distance\r\n    this.grid[this.startRow][this.startCol].distance = 0;\r\n    this.grid[this.finishRow][this.finishCol].endDistance = 0;\r\n    BeginningNodes.sort(compareNodes);\r\n    EndNodes.sort(compareNodesEnd);\r\n\r\n    // continuously look take closest node from beginning then from end while there are nodes left in both.\r\n    while (BeginningNodes.length > 0 && EndNodes.length > 0) {\r\n      // gets closest node from beginning and removes it from the list.\r\n      let currentNode = BeginningNodes.shift();\r\n\r\n      // if we are at the end, return the node and stop search.\r\n      if (currentNode.isFinish) {\r\n        FirstHalf = currentNode;\r\n        break;\r\n      }\r\n\r\n      // if a node is visited it must have been visited by search from other side since\r\n      // we remove nodes from list right after visiting them.\r\n      if (currentNode.visited) {\r\n        FirstHalf = currentNode;\r\n        SecondHalf = currentNode.previousEnd;\r\n        break;\r\n      }\r\n\r\n      // if the closest next node has distance infinity without finding a path, we must\r\n      // be unable to reach it so terminate.\r\n      if (currentNode.distance === Infinity) {\r\n        break;\r\n      }\r\n\r\n      // for each of the neighbours of a node update the distance if the distance through current node\r\n      // is smaller and if that's the case update the previous node to be this node.\r\n      let neighbours = this.getNeighbours(currentNode);\r\n      neighbours.forEach(neighbour => {\r\n        if (!neighbour.isWall) {\r\n          let altDistance = currentNode.distance + 1;\r\n          if (altDistance < neighbour.distance) {\r\n            neighbour.distance = altDistance;\r\n            neighbour.previous = currentNode;\r\n          }\r\n        }\r\n      });\r\n\r\n      // set node to visited and add it to list of visited nodes. Then sort the list again.\r\n      currentNode.visited = true;\r\n      NodesVisitedInOrder.push(currentNode);\r\n      BeginningNodes.sort(compareNodes);\r\n\r\n      // Same process as before but this time we start from the finish.\r\n      currentNode = EndNodes.shift();\r\n      if (currentNode.isStart) {\r\n        SecondHalf = currentNode;\r\n        break;\r\n      }\r\n\r\n      if (currentNode.visited) {\r\n        FirstHalf = currentNode;\r\n        SecondHalf = currentNode.previousEnd;\r\n        break;\r\n      }\r\n\r\n      if (currentNode.endDistance === Infinity) {\r\n        console.log(\"end3\");\r\n        break;\r\n      }\r\n      neighbours = this.getNeighbours(currentNode);\r\n\r\n      neighbours.forEach(neighbour => {\r\n        if (!neighbour.isWall) {\r\n          let altDistance = currentNode.endDistance + 1;\r\n          if (altDistance < neighbour.endDistance) {\r\n            neighbour.endDistance = altDistance;\r\n            neighbour.previousEnd = currentNode;\r\n          }\r\n        }\r\n      });\r\n\r\n      currentNode.visited = true;\r\n      NodesVisitedInOrder.push(currentNode);\r\n      EndNodes.sort(compareNodesEnd);\r\n    }\r\n\r\n    let pathInOrder = [];\r\n\r\n    // add nodes from first half to the path.\r\n    while (FirstHalf) {\r\n      pathInOrder.unshift(FirstHalf);\r\n      FirstHalf = FirstHalf.previous;\r\n    }\r\n\r\n    // add nodes from second hald to the path.\r\n    while (SecondHalf) {\r\n      pathInOrder.push(SecondHalf);\r\n      SecondHalf = SecondHalf.previousEnd;\r\n    }\r\n\r\n    // returns object containing list of visited nodes in order and path nodes in order form start to finish.\r\n    return {\r\n      VisitedInOrder: NodesVisitedInOrder,\r\n      pathInOrder: pathInOrder\r\n    };\r\n  };\r\n\r\n  // given a node, return all the nodes around it. Checks if location is within grid.\r\n  getNeighbours = node => {\r\n    let nodes = [];\r\n\r\n    // checks node above\r\n    if (node.row > 0) nodes.push(this.grid[node.row - 1][node.col]);\r\n\r\n    //checks node below\r\n    if (node.row < this.grid.length - 1) {\r\n      nodes.push(this.grid[node.row + 1][node.col]);\r\n    }\r\n    //checks node to left\r\n    if (node.col > 0) nodes.push(this.grid[node.row][node.col - 1]);\r\n\r\n    //checks node to right\r\n    if (node.col < this.grid[0].length - 1)\r\n      nodes.push(this.grid[node.row][node.col + 1]);\r\n\r\n    return nodes;\r\n  };\r\n}\r\n\r\n// used for sorting. Compares nodes based on distance.\r\nconst compareNodes = (x, y) => {\r\n  if (x.distance < y.distance) {\r\n    return -1;\r\n  }\r\n  if (x.distance > y.distance) {\r\n    return 1;\r\n  }\r\n  return 0;\r\n};\r\n\r\n// Used to sort based on distance from the end rather than the beginning.\r\nconst compareNodesEnd = (x, y) => {\r\n  if (x.endDistance < y.endDistance) {\r\n    return -1;\r\n  }\r\n  if (x.endDistance > y.endDistance) {\r\n    return 1;\r\n  }\r\n  return 0;\r\n};\r\n","// Implementation of A* search using Manhattan Heuristic\r\nexport default class Astar {\r\n  constructor(grid, startLocation, finishLocation) {\r\n    this.grid = grid;\r\n    this.startRow = startLocation[0];\r\n    this.startCol = startLocation[1];\r\n    this.finishRow = finishLocation[0];\r\n    this.finishCol = finishLocation[1];\r\n  }\r\n\r\n  // method to call when solving. Will return an object containing\r\n  // a list of nodes in the order they were visited as well as a list\r\n  // of nodes in the order of the path if a path exists\r\n  solve = () => {\r\n    let NodesVisitedInOrder = []; // list of nodes in the order they are visited while solving\r\n    let UnvisitedNodes = []; // list of all nodes that have not yet been visited\r\n    let Finish = []; // end node if found to get path\r\n\r\n    // reset nodes and calculate the H value for each node based on Manhattan heuristic\r\n    for (let row = 0; row < this.grid.length; row++) {\r\n      for (let column = 0; column < this.grid[0].length; column++) {\r\n        this.grid[row][column].previous = null;\r\n        this.grid[row][column].visited = false;\r\n        this.grid[row][column].distance = Infinity;\r\n        this.grid[row][column].h =\r\n          Math.abs(this.finishRow - row) + Math.abs(this.finishCol - column);\r\n        UnvisitedNodes.push(this.grid[row][column]);\r\n      }\r\n    }\r\n\r\n    // set distance of start node to 0 and then sort nodes by distance\r\n    this.grid[this.startRow][this.startCol].distance = 0;\r\n    UnvisitedNodes.sort(compareNodes);\r\n\r\n    while (UnvisitedNodes.length > 0) {\r\n      // continuously remove closest node from the list\r\n      let currentNode = UnvisitedNodes.shift();\r\n\r\n      // if we are at the end, set Finish to the node and stop search\r\n      if (currentNode.isFinish) {\r\n        Finish = currentNode;\r\n        break;\r\n      }\r\n\r\n      // if the closest next node has distance infinity without finding a path, we must\r\n      // be unable to reach it so terminate\r\n      if (currentNode.distance === Infinity) {\r\n        Finish = currentNode;\r\n        break;\r\n      }\r\n\r\n      // for each of the neighbours of a node update the distance if the distance through the current node\r\n      // is shorter. if that's the case set that nodes previous node to be this node.\r\n      let neighbours = this.getNeighbours(currentNode);\r\n      neighbours.forEach(neighbour => {\r\n        if (!neighbour.isWall) {\r\n          let altDistance = currentNode.distance + 1;\r\n          if (altDistance < neighbour.distance) {\r\n            neighbour.distance = altDistance;\r\n            neighbour.previous = currentNode;\r\n          }\r\n        }\r\n      });\r\n\r\n      // set node to visited and add it to list of visited nodes. Then sort based on distance from start\r\n      // plus h which is the estimated distance to the finish.\r\n      currentNode.visited = true;\r\n      NodesVisitedInOrder.push(currentNode);\r\n      UnvisitedNodes.sort(compareNodes);\r\n    }\r\n    console.log(NodesVisitedInOrder);\r\n\r\n    let pathInOrder = [];\r\n\r\n    while (Finish.previous) {\r\n      Finish = Finish.previous;\r\n      pathInOrder.unshift(Finish);\r\n    }\r\n\r\n    return {\r\n      VisitedInOrder: NodesVisitedInOrder,\r\n      pathInOrder: pathInOrder\r\n    };\r\n  };\r\n\r\n  // given a node, return all the nodes around it. Checks if location is within grid.\r\n  getNeighbours = node => {\r\n    let nodes = [];\r\n\r\n    if (node.row > 0) nodes.push(this.grid[node.row - 1][node.col]);\r\n    if (node.row < this.grid.length - 1) {\r\n      nodes.push(this.grid[node.row + 1][node.col]);\r\n    }\r\n    if (node.col > 0) nodes.push(this.grid[node.row][node.col - 1]);\r\n    if (node.col < this.grid[0].length - 1)\r\n      nodes.push(this.grid[node.row][node.col + 1]);\r\n\r\n    return nodes;\r\n  };\r\n}\r\n\r\n// compare function used for sorting. compares based on h value plus distance of a node.\r\n// if they are the same it will prefer nodes with a lower h which are presumably closer to the finish.\r\nconst compareNodes = (x, y) => {\r\n  if (x.distance + x.h < y.distance + y.h) {\r\n    return -1;\r\n  }\r\n  if (x.distance + x.h > y.distance + y.h) {\r\n    return 1;\r\n  }\r\n  return x.h - y.h;\r\n};\r\n","import React from \"react\";\r\nimport Node from \"./Node\";\r\nimport Dijkstra from \"./Algorithms/Dijkstra\";\r\nimport BiDijkstra from \"./Algorithms/BiDijkstra\";\r\nimport Astar from \"./Algorithms/Astar\";\r\nimport \"./App.css\";\r\n\r\n// Default start and Finish locations for initiating and resetting board.\r\nconst DEFAULT_START = [12, 7];\r\nconst DEFAULT_FINISH = [12, 43];\r\n\r\n// an enum for algorithms\r\nconst ALGORITHMS = { DIJKSTRA: 0, BIDIJKSTRA: 1, ASTAR: 2 };\r\n\r\nexport default class App extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    // initializes the state with default start and finish.\r\n    this.state = {\r\n      placingWall: false,\r\n      removingWall: false,\r\n      movingStart: false,\r\n      movingFinish: false,\r\n      solveSpeed: 20,\r\n      solveMethod: ALGORITHMS.DIJKSTRA,\r\n      solved: false,\r\n      solving: false,\r\n      start: DEFAULT_START.slice(),\r\n      finish: DEFAULT_FINISH.slice(),\r\n      grid: this.CreateEmptyBoard(25, 50),\r\n    };\r\n  }\r\n\r\n  // Handles mouse Click event for a node. Will update state to show what is being moved or\r\n  // if a wall is being placed or removed.\r\n  handleMouseDown = (row, col) => {\r\n    //only lets you edit grid when it's not currently being solved.\r\n    if (!this.state.solving) {\r\n      // Depending on contents of node decide what to do\r\n      if (this.state.grid[row][col].isFinish) {\r\n        this.setState({ movingFinish: true });\r\n      } else if (this.state.grid[row][col].isStart) {\r\n        this.setState({ movingStart: true });\r\n      } else {\r\n        if (this.state.grid[row][col].isWall) {\r\n          this.setState({ removingWall: true });\r\n        } else {\r\n          this.setState({ placingWall: true });\r\n        }\r\n        this.toggleWall(row, col);\r\n      }\r\n      // this.setState({ placingWall: true });\r\n    }\r\n  };\r\n\r\n  // disables editing on node entry when mouse released.\r\n  handleMouseUp = () => {\r\n    this.setState({\r\n      movingFinish: false,\r\n      movingStart: false,\r\n      placingWall: false,\r\n      removingWall: false,\r\n    });\r\n  };\r\n\r\n  // updates node based on any action being performed based on where user first clicked.\r\n  handleMouseEnter = (row, col) => {\r\n    if (!this.state.solving) {\r\n      if (this.state.placingWall && !this.state.grid[row][col].isWall) {\r\n        this.toggleWall(row, col);\r\n      } else if (this.state.removingWall && this.state.grid[row][col].isWall) {\r\n        this.toggleWall(row, col);\r\n      } else if (this.state.movingFinish && !this.state.grid[row][col].isWall) {\r\n        const newGrid = this.state.grid.slice();\r\n        newGrid[row][col].isFinish = true;\r\n        newGrid[this.state.finish[0]][this.state.finish[1]].isFinish = false;\r\n\r\n        // after board is solved, automatically recalculate path when finish is moved\r\n        this.setState({ grid: newGrid, finish: [row, col] }, () => {\r\n          if (this.state.solved) {\r\n            this.startSolving(0);\r\n          }\r\n        });\r\n      } else if (this.state.movingStart && !this.state.grid[row][col].isWall) {\r\n        const newGrid = this.state.grid.slice();\r\n        newGrid[row][col].isStart = true;\r\n        newGrid[this.state.start[0]][this.state.start[1]].isStart = false;\r\n\r\n        // after board is solved, automatically recalculate path when start is moved\r\n        this.setState({ grid: newGrid, start: [row, col] }, () => {\r\n          if (this.state.solved) {\r\n            this.startSolving(0);\r\n          }\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  // toggles wall at given location on grid\r\n  toggleWall = (row, col) => {\r\n    let node = this.state.grid[row][col];\r\n\r\n    if (!node.isStart && !node.isFinish) {\r\n      const newGrid = this.state.grid.slice();\r\n      newGrid[row][col].isWall = !newGrid[row][col].isWall;\r\n      this.setState({ grid: newGrid });\r\n    }\r\n  };\r\n\r\n  // Solve Board based on method in state.\r\n  startSolving = (solveSpeed) => {\r\n    // remove previous visited nodes\r\n\r\n    // if solve speed is not zero, set solving to true which disables input.\r\n    if (solveSpeed !== 0) {\r\n      this.setState({ solving: true });\r\n    }\r\n\r\n    // clear any previous path that was calculated.\r\n    this.clearPath();\r\n\r\n    // set solver based on solveMethod in state.\r\n    var solver;\r\n    let method = this.state.solveMethod;\r\n    switch (method) {\r\n      case ALGORITHMS.ASTAR:\r\n        solver = new Astar(\r\n          this.state.grid,\r\n          this.state.start,\r\n          this.state.finish\r\n        );\r\n        break;\r\n      case ALGORITHMS.DIJKSTRA:\r\n        solver = new Dijkstra(this.state.grid, this.state.start);\r\n        break;\r\n      case ALGORITHMS.BIDIJKSTRA:\r\n        solver = new BiDijkstra(\r\n          this.state.grid,\r\n          this.state.start,\r\n          this.state.finish\r\n        );\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n\r\n    // solve board using solver object\r\n    let solved = solver.solve();\r\n\r\n    let Visited = solved.VisitedInOrder;\r\n\r\n    // if solve speed is 0, solve without delay by just setting all nodes to the correct class\r\n    if (solveSpeed === 0) {\r\n      Visited.forEach((node) => {\r\n        document\r\n          .getElementById(`node ${node.row} ${node.col}`)\r\n          .classList.add(\"Visited\");\r\n      });\r\n      solved.pathInOrder.forEach((node) => {\r\n        document\r\n          .getElementById(`node ${node.row} ${node.col}`)\r\n          .classList.add(\"Path\");\r\n      });\r\n      this.setState({ solved: true });\r\n    } else {\r\n      // if solve speed not 0 animate the nodes one by one.\r\n      this.animateNodes(\r\n        solved.VisitedInOrder,\r\n        solveSpeed,\r\n        \"Visited\",\r\n        \"currentVisit\"\r\n      );\r\n\r\n      // after animating visited nodes, animate path\r\n      setTimeout(() => {\r\n        this.animateNodes(solved.pathInOrder, 40, \"Path\");\r\n        this.setState({ solved: true, solving: false });\r\n      }, solveSpeed * Visited.length);\r\n    }\r\n  };\r\n\r\n  // Goes over every node and removes classes that represent solving process.\r\n  clearPath = () => {\r\n    this.state.grid.forEach((row) => {\r\n      row.forEach((node) => {\r\n        let div = document.getElementById(`node ${node.row} ${node.col}`);\r\n        div.classList.remove(\"Visited\");\r\n        div.classList.remove(\"Path\");\r\n      });\r\n    });\r\n  };\r\n\r\n  // sets a given class to nodes in the list in order at a rate given.\r\n  // headClass is assigned to nodes for 400 ms before the nodeClass is assigned.\r\n  animateNodes(nodes, speed, nodeClass, headClass) {\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      setTimeout(() => {\r\n        let div = document.getElementById(\r\n          `node ${nodes[i].row} ${nodes[i].col}`\r\n        );\r\n        div.classList.add(headClass);\r\n        setTimeout(() => {\r\n          div.classList.remove(headClass);\r\n          div.classList.add(nodeClass);\r\n        }, 400);\r\n      }, speed * i);\r\n    }\r\n  }\r\n\r\n  // creates new grid initializing all nodes to be empty then sets start and finish nodes.\r\n  CreateEmptyBoard = (rows, cols) => {\r\n    let board = [];\r\n\r\n    for (let row = 0; row < rows; row++) {\r\n      let activeRow = [];\r\n      for (let col = 0; col < cols; col++) {\r\n        activeRow.push(createNode(row, col));\r\n      }\r\n      board.push(activeRow);\r\n    }\r\n    board[DEFAULT_START[0]][DEFAULT_START[1]].isStart = true;\r\n    board[DEFAULT_FINISH[0]][DEFAULT_FINISH[1]].isFinish = true;\r\n    return board;\r\n  };\r\n\r\n  // resets the board and state to initial state.\r\n  resetBoard = () => {\r\n    this.setState({\r\n      grid: this.CreateEmptyBoard(25, 50),\r\n      solved: false,\r\n      solving: false,\r\n      start: DEFAULT_START.slice(),\r\n      finish: DEFAULT_FINISH.slice(),\r\n    });\r\n    this.clearPath();\r\n  };\r\n\r\n  render() {\r\n    const { grid, solveSpeed: speed } = this.state;\r\n    return (\r\n      <div className=\"Visualizer\">\r\n        <div className=\"Menu\">\r\n          <label htmlFor=\"algorithm\">Select Algorithm</label>\r\n          <select\r\n            id=\"algorithm\"\r\n            disabled={this.state.solving}\r\n            onChange={(e) => {\r\n              this.setState({ solveMethod: Number(e.target.value) });\r\n            }}>\r\n            <option default value={ALGORITHMS.DIJKSTRA}>\r\n              Dijkstra\r\n            </option>\r\n            <option value={ALGORITHMS.BIDIJKSTRA}>\r\n              Bidirectional Dijkstra\r\n            </option>\r\n            <option value={ALGORITHMS.ASTAR}>A*</option>\r\n          </select>\r\n          <label htmlFor=\"speed\">Solve speed</label>\r\n          <select\r\n            id=\"speed\"\r\n            disabled={this.state.solving}\r\n            onChange={(e) => {\r\n              this.setState({ solveSpeed: Number(e.target.value) });\r\n            }}>\r\n            <option value={50}>Slow</option>\r\n            <option value={10}>Medium</option>\r\n            <option value={3}>Fast</option>\r\n            <option value={0}>Instant</option>\r\n          </select>\r\n\r\n          <button\r\n            className=\"control solve\"\r\n            disabled={this.state.solving}\r\n            onClick={() => {\r\n              this.startSolving(speed);\r\n            }}>\r\n            Start Solving\r\n          </button>\r\n          <button\r\n            className=\"control reset\"\r\n            disabled={this.state.solving}\r\n            onClick={this.resetBoard}>\r\n            Reset Board\r\n          </button>\r\n        </div>\r\n        <table>\r\n          <tbody>\r\n            {grid.map((row, rowIndex) => {\r\n              return (\r\n                <tr className=\"Row\" key={rowIndex}>\r\n                  {row.map((node, nodeIndex) => {\r\n                    return (\r\n                      <Node\r\n                        onMouseEnter={this.handleMouseEnter}\r\n                        onMouseDown={this.handleMouseDown}\r\n                        onMouseUp={this.handleMouseUp}\r\n                        key={nodeIndex}\r\n                        node={node}></Node>\r\n                    );\r\n                  })}\r\n                </tr>\r\n              );\r\n            })}\r\n          </tbody>\r\n        </table>\r\n        <div className=\"Instructions\">\r\n          <h1>Controls</h1>\r\n          <p>\r\n            The green and red nodes are the start and end nodes respectively.\r\n            <br></br>\r\n            These can be moved around freely by pressing on one with the mouse\r\n            button, holding it down and dragging the node to another position.\r\n          </p>\r\n          <img\r\n            src=\"./images/moveStart.gif\"\r\n            alt=\"animation of moving start around\"></img>\r\n          <p>\r\n            We can also create walls by clicking and dragging from any node that\r\n            isn't the start or finish node.<br></br>\r\n            Walls can be removed in the same way, by clicking and dragging from\r\n            a wall node instead\r\n          </p>\r\n          <img src=\"./images/walls.gif\" alt=\"placing and removing walls\"></img>\r\n\r\n          <p>\r\n            After you are happy with how the grid is set up, select an algorithm\r\n            and a solve speed from the dropdown menus at the top and then hit{\" \"}\r\n            <b>Start Solving</b>\r\n          </p>\r\n\r\n          <p>\r\n            After solving, moving the start and end nodes will cause the new\r\n            path to be recalculated in real time\r\n          </p>\r\n          <img src=\"./images/movePath.gif\" alt=\"recalculating path\"></img>\r\n\r\n          <p></p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n// Creates a node with given row and column values but otherwise default values.\r\nconst createNode = (row, col) => {\r\n  return {\r\n    row,\r\n    col,\r\n    isWall: false,\r\n    isStart: false,\r\n    isFinish: false,\r\n    visited: false,\r\n    previous: null,\r\n    distance: null,\r\n    previousEnd: null,\r\n    endDistance: null,\r\n    h: null,\r\n  };\r\n};\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"./index.css\";\r\nimport App from \"./App\";\r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\n"],"sourceRoot":""}